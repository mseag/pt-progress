// Copyright 2020-2021 SIL International
// Types and utilities for interacting with Paratext project progress
import * as books from './books';
import * as fs from 'fs';
import * as phase from './phase';
import * as reporting from './reporting';
import { ProjectStatusType, StatusMap, Status } from './status';

/**
 * Information to write for updating Paratext status.
 * Corresponds to the <status> node in ProjectProgress.xml
 */
interface projectStatusType {
  _attributes: {
    bookChapter: string; // String format is [book number]-[chapter number]
    done: string;        // boolean
    user: string;        // Paratext user name
    date: string;        // ISO 8601 timestamp generated by reporting.getReportingDate()
  }
}

/**
 * Class for handling Paratext project object
 */
export class ParatextProgress {

  /**
   * Allocate 2D array for temporary status of the 66 books and 6 phases
   * @returns {any} 2D array of type stageStatusType
   */
  private generateWorkingObj(): any {
    interface stageStatusType {
      completed: number[];
      date?: Date;
    }
    const b = new books.Books;

    // 2D array for 66 books x 6 phases each
    const workingObj: stageStatusType[][] = [];

    // 1-based index to match bookNum
    for(let bookNum = 1; bookNum <= 66; bookNum++) {
      workingObj[bookNum] = [];
      const bookInfo: books.bookType = b.getBookByNumber(bookNum);

      for(let i=0; i<= 5; i++) {
        // Allocate for each entry (+1 so index can be equal to chapter number)
        const completedArray: number[] = new Array<number>(bookInfo.chapters+1);
        const statusObj: stageStatusType = {
          completed: completedArray
          // Assign completion date later
        };
        workingObj[bookNum][i] = statusObj;
      }
    }

    return workingObj;
  }

  /**
   * Given a 3-character book code and chapter number, create a #-# string
   * corresponding to [Paratext book code number]-[chapter number].
   * Note: Paratext seems to use book number 40 for Matthew in the
   * "Assignments and Progress" tables (vs skipping book 40)
   * @param {string} bookCode 3-character book code
   * @param {number} chapter  Chapter number (0 used for "published" status
   *        and marking a book complete)
   * @returns {string}
   */
  public getBookChapterNumber(bookCode: books.CodeType, chapter: number): string {
    if (chapter < 0) {
      console.warn('getBookChapterNumber() called with negative chapter: ' + chapter +
      ' for book code: ' + bookCode);
    }
    if (bookCode === '000') {
      console.warn('getBookChapterNumber() called with placeholder book code');
    }
    const b = new books.Books;
    const bookInfo = b.getBookByCode(bookCode);
    return `${bookInfo.num}-${chapter}`;
  }

  /**
   * Parse the Paratext project progress `xmlObj` and return the status object.
   * The project status JSON is also written out to a file.
   * @param {obj} xmlObj JSON object of ProgressProgress.xml
   * @param {string} projectName
   * @returns {ProjectStatusType} JSON Object of the project status
   */
  public exportStatus(xmlObj: any, projectName: string): ProjectStatusType {
    // workingObj is an intermediary object used to keep track of completed chapters
    const workingObj: any = this.generateWorkingObj();
    const b = new books.Books;
    const p = new phase.Phase;

    const stages = xmlObj.ProgressInfo.Stages.Stage;
    if (stages) {
      stages.forEach((stage: any, stageIndex: number) => {
        const statusArray = stage.Task.Status;
        if (statusArray) {
          statusArray.forEach((status: any, statusIndex: number) => {
            if (status.done === 'true') {
              // Process a completed chapter, skipping chapter "0"
              const [bookNumber, bookChapter] = status.bookChapter.split("-");

              // Special handling for for chapter "0" where we only care about
              // 'publish' stage if the completion date isn't filled
              if (bookChapter == 0) {
                if (p.stageIndexToPhase(stageIndex) === 'publish' &&
                   !workingObj[bookNumber][stageIndex].date) {
                  // Mark all the chapters complete
                  const bt: books.bookType = b.getBookByNumber(bookNumber);
                  const totalChapters : number = bt.chapters;
                  workingObj[bookNumber][stageIndex].completed.fill(1, 1, totalChapters+1);

                  // Update the latest completion date
                  workingObj[bookNumber][stageIndex].date = new Date(status.date);
                }
                return;
              }

              // Mark the completed chapter by adding it to the completed chapter array
              workingObj[bookNumber][stageIndex].completed[bookChapter] = 1;

              // Update the latest completion date
              const currentCompletionDate: Date = new Date(status.date);
              if (!workingObj[bookNumber][stageIndex].date) {
                workingObj[bookNumber][stageIndex].date = currentCompletionDate;
              } else if (new Date(status.date) < currentCompletionDate) {
                status.date = currentCompletionDate;
              }
            }
        });
        }
      });
    } else {
      console.warn("No Paratext project status found for " + projectName);
    }

    // Convert the working object into a ProjectStatusType object
    const progressObj: ProjectStatusType = {};

    // Reducer method to accumulate the number of completed chapters
    const reducer = (accumulator: number, item: number) => {
      return accumulator + item;
    }

    workingObj.forEach(function (bookObj: any, bookIndex: number) {
      const phaseArray: any[] = [];
      const bookProgressObj: any = {};
      const code: books.CodeType = b.getBookByNumber(bookIndex).code;

      bookObj.forEach(function (phaseObj: any, stageIndex: number) {
        if (phaseObj.date) {
          const completedChapters: number = phaseObj.completed.reduce(reducer, 0);
          const dateStr: string = phaseObj.date.toString();
          const status: Status = new Status(
            completedChapters,
            1, // Assume starting with chapter 1
            reporting.getReportingQuarter(dateStr),
            reporting.getReportingYear(dateStr)
          );

          const ph: phase.PhaseType = p.stageIndexToPhase(stageIndex);
          bookProgressObj[ph] = status
        }
      });

      if (Object.keys(bookProgressObj).length > 0) {
        phaseArray.push(bookProgressObj);

        progressObj[code] = phaseArray;
      }
    });

    // Write the status to a file.
    if (Object.keys(progressObj).length > 0) {
      const filename = `${projectName}-progress-export.json`;
      if (fs.existsSync(filename)) {
        console.warn("Overwriting status file: " + filename);
      }
      fs.writeFileSync(filename, JSON.stringify(progressObj, null, 2));
      console.info("Project status written to " + filename);
    } else {
      console.warn("Project progress empty for " + projectName);
    }

    return progressObj
  }

  /**
   * Update the assignment and status sections of xmlObj for each Paratext phase.
   * xmlObj is modified during the process.
   * @param {ProjectStatusType} progressObj   JSON object from the project reports which contains completed info
   * @param {object} xmlObj        JSON object of ProgressProgress.xml which is modified
   * @param {string} user          Paratext user for each updated status element
   * @param {Reporting} reportingInfo Information for the project
   */
  public update(progressObj: ProjectStatusType, xmlObj: any , user: string,
      reportingInfo: reporting.Reporting): void {
    // Fill out progress for the project phase
    // Not using forEach to maintain context
    const b = new books.Books;
    const p = new phase.Phase();
    for (const bookKey in progressObj) {
      const bookCode: books.CodeType = bookKey as books.CodeType;
      const currentBook: books.bookType = b.getBookByCode(bookCode);

      const statusArray = progressObj[bookCode] as StatusMap[];
      for(const bookObj of statusArray) {
        for (const phaseKey in bookObj) {
          const ppPhase: phase.PhaseType = phaseKey as phase.PhaseType;
          const phaseObj: Status = bookObj[ppPhase] as Status;

          const phaseReportingInfo: reporting.Reporting = new reporting.Reporting(
            reportingInfo.projectName,
            phaseObj.quarter,
            phaseObj.year);
          const reportingDate = reporting.getReportingDate(phaseReportingInfo);
          const stageIndex: number = p.phaseToStageIndex(ppPhase);

          // TODO: Investigate if the XPath xmlObj.ProgressInfo.Stages.Stage[stageIndex].Task
          // is valid across the Paratext projects

          // Keep a reference to Task so xmlObj will be modified
          let task = xmlObj.ProgressInfo.Stages.Stage[stageIndex].Task;
          if (Array.isArray(task)) {
            task = xmlObj.ProgressInfo.Stages.Stage[stageIndex].Task[0];
          }

          // Update Assignments node.
          if (task.Assignments === undefined) {
            console.warn("Warning: Assignments undefined for " + bookCode + " in phase " + ppPhase + ". Initializing...")
            task.Assignments = [];
          }
          let assignmentsArray = task.Assignments
          // Convert from JSON to JSONArray as needed so we can push new assignments
          if (!Array.isArray(assignmentsArray)) {
            task.Assignments = [task.Assignments]
            assignmentsArray = task.Assignments;
          }
          const existingIndex: number = assignmentsArray.findIndex((el: any) =>
            el._attributes && el._attributes.book === bookCode);
          if (existingIndex == -1) {
            // Add new assignment
            const updatedAssignment: any = {
              _attributes: {}
            };
            updatedAssignment._attributes.book = bookCode;
            assignmentsArray.push(updatedAssignment)
          }

          // Update Status node.
          if (task.Status === undefined) {
            console.warn("Warning: Status undefined for " + bookCode + " in phase " + ppPhase + ". Initializing...")
            task.Status = []
          }
          let statusArray: projectStatusType[] = task.Status
          // Convert from JSON to JSONArray as needed so we can push new status
          if (!Array.isArray(statusArray)) {
            task.Status = [task.Status]
            statusArray = task.Status;
          }

          // Range check starting and end chapter numbers (starting index 1)
          const startingCh = Number(phaseObj.startingChapter);
          const endCh = Math.min(startingCh + Number(phaseObj.chapters), currentBook.chapters+1);

          for (let ch = startingCh; ch < endCh; ch++) {
            let bookChapterNumber: string;
            if (ppPhase === "publish") {
              // Publishing is treated as Chapter "0", so only process the startingCh:
              if (ch == startingCh) {
                bookChapterNumber = this.getBookChapterNumber(bookCode, 0);
              } else {
                continue;
              }
            } else {
              bookChapterNumber = this.getBookChapterNumber(bookCode, ch);
            }

            let updatedStatus: projectStatusType;
            const existingIndex: number = statusArray.findIndex((el: projectStatusType) =>
              el._attributes && el._attributes.bookChapter === bookChapterNumber);
            if (existingIndex != -1) {
              // Update existing status to "Done"
              if (statusArray[existingIndex]._attributes.done != "true") {
                // no change to bookChapter
                statusArray[existingIndex]._attributes.done = "true";
                statusArray[existingIndex]._attributes.user = user;
                statusArray[existingIndex]._attributes.date = reportingDate
              }
            } else {
              // Create new status
              updatedStatus = {
                _attributes: {
                  bookChapter: bookChapterNumber,
                  done: "true",
                  user: user,
                  date: reportingDate}
              };

              statusArray.push(updatedStatus);
            }
          }

          //#region Disabled marking "published"
          /*
           Disabled because this was erroneously marking books as "Published"
          // Check if entire book can be marked complete
          let bookComplete = true;
          for (let ch = 1; ch <= currentBook.chapters; ch++) {
            const bookChapterNumber = this.getBookChapterNumber(bookCode, ch);
            existingIndex = statusArray.findIndex(el => el.bookChapter === bookChapterNumber);
            if (existingIndex == -1 || statusArray[existingIndex].done != "true") {
              bookComplete = false;
              break;
            }
          }

          if (bookComplete) {
            // Paratext uses chapter "0" to mark a book complete
            const bookChapterNumber = this.getBookChapterNumber(bookCode, 0);

            let updatedStatus: projectStatusType;
            existingIndex = statusArray.findIndex(el => el.bookChapter === bookChapterNumber);
            if (existingIndex != -1) {
              // Update existing status to "Done"
                if (statusArray[existingIndex].done != "true") {
                // no change to bookChapter
                statusArray[existingIndex].done = "true";
                statusArray[existingIndex].user = user;
                statusArray[existingIndex].date = reportingDate
                }
            } else {
              // Create new status
              updatedStatus = {
                bookChapter: bookChapterNumber,
                done: "true",
                user: user,
                date: reportingDate};

              statusArray.push(updatedStatus);
            }
          }
          */
          // #endregion
        }
      }
    }
  }
}

// Copyright 2020 SIL International
// Types and utilities for updating Paratext progress
import * as books from './books';
import * as phase from './phase';
import * as reporting from './reporting';
import { ProjectStatusType, StatusMap, Status } from './status';

/**
 * Information to write for updating Paratext status.
 * Corresponds to the <status> node in ProjectProgress.xml
 */
interface projectStatusType {
  bookChapter: string; // String format is [book number]-[chapter number]
  done: string;        // boolean
  user: string;        // Paratext user name
  date: string;        // ISO 8601 timestamp generated by reporting.getReportingDate()
}

/**
 * Class to update Paratext project object
 */
export class ParatextProgress {
  /**
   * Given a 3-character book code and chapter number, create a #-# string
   * corresponding to [Paratext book code number]-[chapter number].
   * Note: Paratext seems to use book number 40 for Matthew in the
   * "Assignments and Progress" tables (vs skipping book 40)
   * @param {string} bookCode 3-character book code
   * @param {number} chapter  Chapter number (0 used for "published" status
   *        and marking a book complete)
   * @returns {string}
   */
  public getBookChapterNumber(bookCode: books.CodeType, chapter: number): string {
    if (chapter < 0) {
      console.warn('getBookChapterNumber() called with negative chapter ' + chapter);
    }
    if (bookCode === '000') {
      console.warn('getBookChapterNumber() called with placeholder book code');
    }
    const b = new books.Books;
    const bookInfo = b.getBookByCode(bookCode);
    return `${bookInfo.num}-${chapter}`;
  }

  /**
   * Update the assignment and status sections of xmlObj for each Paratext phase.
   * xmlObj is modified during the process.
   * @param {ProjectStatusType} progressObj   JSON object from the project reports which contains completed info
   * @param {object} xmlObj        JSON object of ProgressProgress.xml which is modified
   * @param {string} user          Paratext user for each updated status element
   * @param {QuarterType|undefined} quarter If specified, only update Paratext status for the matching quarter/year
   * @param {Reporting} reportingInfo Information for the project
   */
  public update(progressObj: ProjectStatusType, xmlObj: any , user: string,
      reportingInfo: reporting.Reporting, quarter: reporting.QuarterType|undefined): void {
    // Fill out progress for the project phase
    // Not using forEach to maintain context
    const b = new books.Books;
    const p = new phase.Phase();
    for (const bookKey in progressObj) {
      const bookCode: books.CodeType = bookKey as books.CodeType;
      const currentBook: books.bookType = b.getBookByCode(bookCode);

      const statusArray = progressObj[bookCode] as StatusMap[];
      for(const bookObj of statusArray) {
        for (const phaseKey in bookObj) {
          const ppPhase: phase.PhaseType = phaseKey as phase.PhaseType;
          const phaseObj: Status = bookObj[ppPhase] as Status;

          // If quarter defined, only handle current reporting quarter & year
          if ((quarter === undefined) || (quarter &&
              phaseObj.quarter === reportingInfo.quarter &&
              phaseObj.year === parseInt(reportingInfo.year))) {

            const phaseReportingInfo: reporting.Reporting = new reporting.Reporting(
              reportingInfo.projectName,
              phaseObj.quarter,
              phaseObj.year.toString());
            const reportingDate = reporting.getReportingDate(phaseReportingInfo);
            const stageIndex: number = p.phaseToStageIndex(ppPhase);

            // Investigate if the XPath xmlObj.ProgressInfo.Stages.Stage[stageIndex].Task
            // is valid across the Paratext projects

            // Keep a reference to Task so xmlObj will be modified
            let task = xmlObj.ProgressInfo.Stages.Stage[stageIndex].Task;
            if (Array.isArray(task)) {
              task = xmlObj.ProgressInfo.Stages.Stage[stageIndex].Task[0];
            }

            // Update Assignments node.
            if (task.Assignments === undefined) {
              console.warn("Warning: Assignments undefined for " + bookCode + " in phase " + ppPhase + ". Initializing...")
              task.Assignments = [];
            }
            let assignmentsArray = task.Assignments
            // Convert from JSON to JSONArray as needed so we can push new assignments
            if (!Array.isArray(assignmentsArray)) {
              task.Assignments = [task.Assignments]
              assignmentsArray = task.Assignments;
            }
            let existingIndex: number = assignmentsArray.findIndex((el: any) => el.book === bookCode);
            if (existingIndex == -1) {
              // Add new assignment
              const updatedAssignment: any = {};
              updatedAssignment.book = bookCode;
              assignmentsArray.push(updatedAssignment)
            }

            // Update Status node.
            if (task.Status === undefined) {
              console.warn("Warning: Status undefined for " + bookCode + " in phase " + ppPhase + ". Initializing...")
              task.Status = []
            }
            let statusArray: projectStatusType[] = task.Status
            // Convert from JSON to JSONArray as needed so we can push new status
            if (!Array.isArray(statusArray)) {
              task.Status = [task.Status]
              statusArray = task.Status;
            }

            const startingCh: number = phaseObj.startingChapter;
            for (let ch = startingCh; ch < startingCh+phaseObj.chapters; ch++) {
              let bookChapterNumber: string;
              if (ppPhase === "publish") {
                // Publishing only deals with Chapter "0":
                // Could optimize this to not happen for each chapter
                bookChapterNumber = this.getBookChapterNumber(bookCode, 0);
              } else {
                bookChapterNumber = this.getBookChapterNumber(bookCode, ch);
              }

              let updatedStatus: projectStatusType;
              const existingIndex: number = statusArray.findIndex(el => el.bookChapter === bookChapterNumber);
              if (existingIndex != -1) {
                // Update existing status to "Done"
                if (statusArray[existingIndex].done != "true") {
                  // no change to bookChapter
                  statusArray[existingIndex].done = "true";
                  statusArray[existingIndex].user = user;
                  statusArray[existingIndex].date = reportingDate
                }
              } else {
                // Create new status
                updatedStatus = {
                  bookChapter: bookChapterNumber,
                  done: "true",
                  user: user,
                  date: reportingDate};

                statusArray.push(updatedStatus);
              }
            }

            // Check if entire book can be marked complete
            let bookComplete = true;
            for (let ch = 1; ch <= currentBook.chapters; ch++) {
              const bookChapterNumber = this.getBookChapterNumber(bookCode, ch);
              existingIndex = statusArray.findIndex(el => el.bookChapter === bookChapterNumber);
              if (existingIndex == -1 || statusArray[existingIndex].done != "true") {
                bookComplete = false;
                break;
              }
            }

            if (bookComplete) {
              // Paratext uses chapter "0" to mark a book complete
              const bookChapterNumber = this.getBookChapterNumber(bookCode, 0);

              let updatedStatus: projectStatusType;
              existingIndex = statusArray.findIndex(el => el.bookChapter === bookChapterNumber);
              if (existingIndex != -1) {
                // Update existing status to "Done"
                  if (statusArray[existingIndex].done != "true") {
                  // no change to bookChapter
                  statusArray[existingIndex].done = "true";
                  statusArray[existingIndex].user = user;
                  statusArray[existingIndex].date = reportingDate
                  }
              } else {
                // Create new status
                updatedStatus = {
                  bookChapter: bookChapterNumber,
                  done: "true",
                  user: user,
                  date: reportingDate};

                statusArray.push(updatedStatus);
              }
            }

          }
        }
      }
    }
  }
}
